import 'dart:async';
import 'package:chatview_utils/chatview_utils.dart';
import 'package:flutter/foundation.dart';
import '../../models/chat_room.dart';
import '../../models/chat_room_display_metadata.dart';
import '../../models/chat_room_metadata.dart';
import '../../models/chat_room_participant.dart';
import '../../models/config/message_ops_config.dart';
import '../../models/message_dm.dart';
import '../database_service.dart';
import '../../enum.dart';
import '../../typedefs.dart';

class ChatViewLocalDatabase implements DatabaseService {
  @override
  Future<Message?> addMessage({
    required int retry,
    required String chatId,
    required Message message,
    required bool useAutoGeneratedId,
    required MessageOpsConfig messageOpsConfig,
  }) async => message;

  @override
  Future<bool> addUserInGroup({
    required int retry,
    required String chatId,
    required String userId,
    required Role role,
    required bool includeAllChatHistory,
    DateTime? startDate,
  }) async => true;

  @override
  Stream<ChatRoom?> chatRoomChangesStream({
    required String userId,
    required bool includeEmptyChats,
    required bool includeUnreadMessagesCount,
    required ValueSetter<String>? onRemovedChat,
    int? limit,
  }) => Stream.value(null);

  @override
  Future<String?> createGroupChat({
    required String userId,
    required String groupName,
    required Map<String, Role> participants,
    String? groupProfilePic,
    String? chatRoomId,
  }) async => 'mock_group_id';

  @override
  Future<String?> createOneToOneChat({
    required String userId,
    required String otherUserId,
    String? chatRoomId,
  }) async => 'mock_chat_id';

  @override
  Future<bool> deleteChat({
    required int retry,
    required String chatId,
    DeleteChatMediaCallback? deleteMedia,
  }) async => true;

  @override
  Future<bool> deleteMessage({
    required int retry,
    required String chatId,
    required Message message,
    required MessageOpsConfig messageConfig,
  }) async => true;

  @override
  Future<String?> findOneToOneChatRoom({
    required int retry,
    required String userId,
    required String otherUserId,
  }) async => null;

  @override
  Stream<ChatRoomDisplayMetadata> getChatRoomDisplayMetadataStream({
    required ChatRoomType chatRoomType,
    required String chatId,
    String? userId,
  }) => Stream.value(const ChatRoomDisplayMetadata(chatName: 'Mock User', chatProfilePhoto: ''));

  @override
  Future<ChatRoomMetadata?> getChatRoomMetadata({
    required int retry,
    required String chatId,
    required String userId,
  }) async => ChatRoomMetadata(
    chatRoomType: ChatRoomType.oneToOne,
    currentUser: ChatUser(id: userId, name: 'You'),
    otherUsers: [ChatUser(id: 'other', name: 'Other')],
  );

  @override
  Stream<List<ChatRoomParticipant>> getChatRoomParticipantsStream({
    required String userId,
    required String chatId,
    int? limit,
  }) => Stream.value([]);

  @override
  Stream<Map<String, ChatRoomParticipant>> getChatRoomUsersMetadataStream({
    required String chatId,
    required String userId,
    required bool observeUserInfoChanges,
    int? limit,
  }) => Stream.value({});

  @override
  Stream<List<ChatRoom>> getChatsStream({
    required String userId,
    required ChatSortBy sortBy,
    required bool includeEmptyChats,
    required bool includeUnreadMessagesCount,
    int? limit,
  }) => Stream.value([
    ChatRoom(
      chatId: 'mock_chat_id',
      chatRoomType: ChatRoomType.oneToOne,
      users: [],
    )
  ]);

  @override
  Stream<ChatRoomDisplayMetadata> getGroupChatDisplayMetadataStream(String chatId) 
    => Stream.value(const ChatRoomDisplayMetadata(chatName: 'Mock Group', chatProfilePhoto: ''));

  @override
  Future<List<MessageDm>> getMessages({
    required int retry,
    required String chatId,
    required MessageSortBy sortBy,
    required MessageSortOrder sortOrder,
    int? limit,
    dynamic startAfterDocument,
  }) async => [];

  @override
  Stream<List<Message>> getMessagesStream({
    required String chatId,
    required MessageSortBy sortBy,
    required MessageSortOrder sortOrder,
    int? limit,
    dynamic startAfterDocument,
    DateTime? from,
  }) => Stream.value([]);

  @override
  Stream<Map<Message, DocumentType>> getMessagesStreamWithOperationType({
    required String chatId,
    required MessageSortBy sortBy,
    required MessageSortOrder sortOrder,
    int? limit,
  }) => Stream.value({});

  @override
  Stream<List<MessageDm>> getMessagesStreamWithSnapshot({
    required String chatId,
    required MessageSortBy sortBy,
    required MessageSortOrder sortOrder,
    int? limit,
    dynamic startAfterDocument,
    DateTime? from,
  }) => Stream.value([]);

  @override
  Stream<int> getUnreadMessagesCount({
    required String chatId,
    required String userId,
    DateTime? from,
  }) => Stream.value(0);

  @override
  Future<DateTime?> getUserMembershipTimestamp({
    required int retry,
    required String chatId,
    required String userId,
  }) async => DateTime.now();

  @override
  Stream<ChatUser?> getUserStreamById(String userId) => Stream.value(ChatUser(id: userId, name: 'You'));

  @override
  Future<List<ChatUser>> getUsers({required int retry, int? limit}) async => [
    ChatUser(id: 'other', name: 'Other User')
  ];

  @override
  Stream<List<ChatUser>> getUsersStream({int? limit}) => Stream.value([
    ChatUser(id: 'other', name: 'Other User')
  ]);

  @override
  Future<bool> removeUserFromGroup({
    required int retry,
    required String chatId,
    required String userId,
    required String removeUserId,
    required bool deleteGroupIfSingleUser,
    required DeleteChatMediaCallback deleteChatMedia,
  }) async => true;

  @override
  Future<void> updateChatRoomUserMetadata({
    required int retry,
    required String chatId,
    required String userId,
    TypeWriterStatus? typingStatus,
    MembershipStatus? membershipStatus,
    PinStatus? pinStatus,
    MuteStatus? muteStatus,
    Map<String, dynamic>? chatRoomUserData,
    ValueGetter<ChatRoomParticipant>? ifDataNotFound,
  }) async {}

  @override
  Future<bool> updateGroupChat({
    required int retry,
    required String chatId,
    String? groupName,
    String? groupProfilePic,
  }) async => true;

  @override
  Future<void> updateMessage({
    required int retry,
    required String userId,
    required String chatId,
    required Message message,
    MessageStatus? status,
    ReactionCallback? reaction,
  }) async {}

  @override
  Future<List<Message>> getSurroundingMessages({
    required String chatId,
    required int retry,
    required String messageId,
    required int batchSize,
    required MessageSortBy sortBy,
    required MessageSortOrder sortOrder,
  }) async => [];

  @override
  Future<bool> updateUserActiveStatus({
    required int retry,
    required String userId,
    required UserActiveStatus userStatus,
  }) async => true;

  @override
  Future<List<Message>> getPreviousMessages({
    required String chatId,
    required int retry,
    required String messageId,
    required int batchSize,
  }) async => [];

  @override
  Future<List<Message>> getNextMessages({
    required String chatId,
    required int retry,
    required String messageId,
    required int batchSize,
  }) async => [];
}
