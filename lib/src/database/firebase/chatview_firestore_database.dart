import 'dart:collection';

import 'package:chatview_utils/chatview_utils.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/foundation.dart';
import 'package:rxdart/rxdart.dart';
import 'package:uuid/uuid.dart';

import '../../chatview_connect.dart';
import '../../chatview_connect_constants.dart';
import '../../enum.dart';
import '../../extensions.dart';
import '../../models/chat_room.dart';
import '../../models/chat_room_display_metadata.dart';
import '../../models/chat_room_metadata.dart';
import '../../models/chat_room_participant.dart';
import '../../models/config/firebase/firestore_chat_collection_name_config.dart';
import '../../models/config/firebase/firestore_chat_database_path_config.dart';
import '../../models/config/message_ops_config.dart';
import '../../models/message_dm.dart';
import '../../models/user_chat_metadata.dart';
import '../../models/user_metadata.dart';
import '../../typedefs.dart';
import '../database_service.dart';
import 'chatview_firestore_collections.dart';

/// provides methods for getting, adding, updating and deleting message
/// and messages streams from Firebase Firestore.
final class ChatViewFireStoreDatabase implements DatabaseService {
  static const String _typingStatus = 'typing_status';
  static const String _status = 'status';
  static const String _reaction = 'reaction';
  static const String _updateAt = 'update_at';
  static const String _update = 'update';
  static const String _groupName = 'group_name';
  static const String _groupPhotoUrl = 'group_photo_url';
  static const String _createdAt = 'createdAt';
  static const String _membershipStatus = 'membership_status';
  static const String _membershipStatusTimestamp =
      'membership_status_timestamp';
  static const String _pinStatusTimestamp = 'pin_status_timestamp';
  static const String _pinStatus = 'pin_status';
  static const String _muteStatus = 'mute_status';

  FirestoreChatDatabasePathConfig? get _chatDatabasePathConfig =>
      ChatViewConnect.instance.getFirestoreChatDatabasePathConfig;

  FirestoreChatCollectionNameConfig get _chatCollectionNameConfig =>
      ChatViewConnect.instance.getFirestoreChatCollectionNameConfig;

  String _chatRoomCollectionPath(String chatId) {
    final collectionPath = '${_chatCollectionNameConfig.chats}/$chatId';
    assert(
      collectionPath.isValidFirestoreDocumentName,
      'invalid Firestore document path provided',
    );
    return collectionPath;
  }

  CollectionReference<Message?> _messageCollectionRef(String chatId) =>
      ChatViewFireStoreCollections.messageCollection(
        _chatRoomCollectionPath(chatId),
      );

  CollectionReference<ChatUser?> _usersCollectionRef() =>
      ChatViewFireStoreCollections.userCollection(
        _chatDatabasePathConfig?.userCollectionPath,
      );

  @override
  Future<Message?> addMessage({
    required int retry,
    required String chatId,
    required Message message,
    required bool useAutoGeneratedId,
    required MessageOpsConfig messageOpsConfig,
  }) async {
    try {
      final url = await messageOpsConfig.uploadMedia(message);
      final messageCollectionRef = _messageCollectionRef(chatId);
      final newMessage = message.copyWith(
        message: url,
        updateAt: message.createdAt,
        status: MessageStatus.delivered,
      );

      Message? updatedMessage;

      if (useAutoGeneratedId) {
        final result = await messageCollectionRef.add(newMessage);
        updatedMessage = newMessage.copyWith(id: result.id);
      } else {
        await messageCollectionRef.doc(newMessage.id).set(newMessage);
        updatedMessage = newMessage;
      }

      return updatedMessage;
    } catch (_) {
      if (retry == 0) rethrow;
      return addMessage(
        retry: --retry,
        chatId: chatId,
        message: message,
        messageOpsConfig: messageOpsConfig,
        useAutoGeneratedId: useAutoGeneratedId,
      );
    }
  }

  @override
  Stream<List<MessageDm>> getMessagesStreamWithSnapshot({
    required String chatId,
    required MessageSortBy sortBy,
    required MessageSortOrder sortOrder,
    int? limit,
    DocumentSnapshot<Message?>? startAfterDocument,
    DateTime? from,
  }) {
    return _getMessageStreamBase<List<MessageDm>>(
      from: from,
      limit: limit,
      sortBy: sortBy,
      chatId: chatId,
      sortOrder: sortOrder,
      startAfterDocument: startAfterDocument,
      mapper: _getMessagesDmFromSnapshot,
    );
  }

  @override
  Stream<List<Message>> getMessagesStream({
    required String chatId,
    required MessageSortBy sortBy,
    required MessageSortOrder sortOrder,
    int? limit,
    DocumentSnapshot<Message?>? startAfterDocument,
    DateTime? from,
  }) {
    return _getMessageStreamBase<List<Message>>(
      from: from,
      limit: limit,
      sortBy: sortBy,
      chatId: chatId,
      sortOrder: sortOrder,
      startAfterDocument: startAfterDocument,
      mapper: (docSnapshot) {
        final messages = docSnapshot.docs;
        final messagesLength = messages.length;
        return [
          for (var i = 0; i < messagesLength; i++)
            if (messages[i].data() case final message?) message,
        ];
      },
    );
  }

  @override
  Stream<Map<Message, DocumentType>> getMessagesStreamWithOperationType({
    required String chatId,
    required MessageSortBy sortBy,
    required MessageSortOrder sortOrder,
    int? limit,
  }) {
    return _getMessageStreamBase<Map<Message, DocumentType>>(
      limit: limit,
      chatId: chatId,
      sortBy: sortBy,
      sortOrder: sortOrder,
      mapper: (docSnapshot) {
        final messagesChanges = docSnapshot.docChanges;
        final messagesChangesLength = messagesChanges.length;
        final messages = <Message, DocumentType>{};
        for (var i = 0; i < messagesChangesLength; i++) {
          final changedDoc = messagesChanges[i];
          final messageDoc = changedDoc.doc;
          final message = messageDoc.data()?.copyWith(id: messageDoc.id);
          if (message == null) continue;
          messages[message] = changedDoc.type.toDocumentType();
        }
        return messages;
      },
    );
  }

  @override
  Stream<int> getUnreadMessagesCount({
    required String chatId,
    required String userId,
    DateTime? from,
  }) {
    return _getMessageStreamBase(
      from: from,
      chatId: chatId,
      sortBy: MessageSortBy.none,
      sortOrder: MessageSortOrder.desc,
      mapper: (docSnapshot) {
        final docs = docSnapshot.docs;
        final docsLength = docs.length;
        var count = 0;
        for (var i = 0; i < docsLength; i++) {
          final message = docs[i].data();
          if (message == null ||
              message.sentBy == userId ||
              message.status.isRead) {
            continue;
          }
          count++;
        }
        return count;
      },
    );
  }

  Stream<T> _getMessageStreamBase<T>({
    required String chatId,
    required MessageSortBy sortBy,
    required MessageSortOrder sortOrder,
    required MessageQueryMapper<T> mapper,
    int? limit,
    DocumentSnapshot<Message?>? startAfterDocument,
    DateTime? from,
  }) {
    final messageCollectionRef = _messageCollectionRef(chatId).toMessageQuery(
      sortBy: sortBy,
      sortOrder: sortOrder,
      limit: limit,
      startAfterDocument: startAfterDocument,
      whereFieldName: _createdAt,
      whereFieldIsGreaterThanOrEqualTo: from,
    );
    return messageCollectionRef.snapshots().distinct().map<T>(mapper);
  }

  @override
  Future<List<MessageDm>> getMessages({
    required int retry,
    required String chatId,
    required MessageSortBy sortBy,
    required MessageSortOrder sortOrder,
    int? limit,
    DocumentSnapshot<Message?>? startAfterDocument,
  }) async {
    try {
      final messageCollectionRef = _messageCollectionRef(chatId).toMessageQuery(
        sortBy: sortBy,
        sortOrder: sortOrder,
        limit: limit,
        startAfterDocument: startAfterDocument,
      );

      final result = await messageCollectionRef.get();
      return _getMessagesDmFromSnapshot(result);
    } catch (_) {
      if (retry == 0) rethrow;
      return getMessages(
        retry: --retry,
        chatId: chatId,
        sortBy: sortBy,
        sortOrder: sortOrder,
        limit: limit,
        startAfterDocument: startAfterDocument,
      );
    }
  }

  List<MessageDm> _getMessagesDmFromSnapshot(QuerySnapshot<Message?> result) {
    final docs = result.docs;
    final docsLength = docs.length;
    return [
      for (var i = 0; i < docsLength; i++)
        if (docs[i].data() case final message?)
          MessageDm(
            message: message.copyWith(id: docs[i].id),
            snapshot: docs[i],
          ),
    ];
  }

  @override
  Future<bool> deleteMessage({
    required int retry,
    required String chatId,
    required Message message,
    required MessageOpsConfig messageConfig,
  }) async {
    try {
      await messageConfig.deleteMedia(message);
      await _messageCollectionRef(chatId).doc(message.id).delete();
      return true;
    } on FirebaseException catch (_) {
      if (retry == 0) return false;
      return deleteMessage(
        retry: --retry,
        chatId: chatId,
        message: message,
        messageConfig: messageConfig,
      );
    }
  }

  @override
  Future<void> updateMessage({
    required int retry,
    required String userId,
    required String chatId,
    required Message message,
    MessageStatus? status,
    ReactionCallback? reaction,
  }) async {
    try {
      final isReactionRemoved = message.reaction.reactions.isEmpty;
      final updateData = <String, dynamic>{
        if (status != null) _status: ChatViewConnectConstants.emptyString,
        if (reaction != null && !isReactionRemoved) _reaction: userId,
      };

      final data = <String, dynamic>{
        _update: updateData,
        if (status case final status?) _status: status.name,
        if (reaction != null) ...{
          _reaction: message.reaction.toJson(),
          _updateAt: isReactionRemoved
              ? Timestamp.fromDate(message.createdAt)
              : FieldValue.serverTimestamp(),
        },
      };

      if (data.isEmpty) return;

      await _messageCollectionRef(chatId).doc(message.id).update(data);
    } catch (_) {
      if (retry == 0) rethrow;
      return updateMessage(
        retry: --retry,
        userId: userId,
        chatId: chatId,
        message: message,
        status: status,
        reaction: reaction,
      );
    }
  }

  @override
  Stream<List<ChatRoomParticipant>> getChatRoomParticipantsStream({
    required String userId,
    required String chatId,
    bool includeCurrentUser = true,
    bool listenChangesForCurrentUser = false,
    int? limit,
  }) {
    final collectionPath = _chatRoomCollectionPath(chatId);

    final currentChatID =
        collectionPath.chatId ?? ChatViewConnectConstants.emptyString;

    if (currentChatID.isEmpty) {
      return Stream.error('Chat ID not found from path: $collectionPath');
    }

    final userCollection =
        ChatViewFireStoreCollections.chatParticipantsCollection(collectionPath)
            .toQuery(limit: limit);

    return userCollection.snapshots().where((userSnapshot) {
      // Check if there are any document changes for other users
      final docChanges = userSnapshot.docChanges;
      if (docChanges.isEmpty) return true;

      final hasOtherUserChanges = listenChangesForCurrentUser ||
          docChanges.any((change) => change.doc.id != userId);
      return hasOtherUserChanges;
    }).switchMap(
      (userSnapshot) {
        final docs = userSnapshot.docs;
        if (docs.isEmpty) {
          return Stream.error('No users found in chat ID: $currentChatID');
        }
        final docsLength = docs.length;
        final listOfChatParticipantStream = <Stream<ChatRoomParticipant>>[];
        for (var i = 0; i < docsLength; i++) {
          final doc = docs[i];
          final chatUserId = doc.id;
          if (!includeCurrentUser && chatUserId == userId) {
            continue;
          }
          final chatRoomUser = doc.data();
          if (chatRoomUser == null) continue;
          listOfChatParticipantStream.add(
            _getUserInfoWithStatusStream(chatUserId).map(
              (userResult) => chatRoomUser.copyWith(
                chatUser: userResult.user,
                userActiveStatus: userResult.userActiveStatus,
              ),
            ),
          );
        }
        return listOfChatParticipantStream.isEmpty
            ? Stream.value([])
            : Rx.combineLatestList(listOfChatParticipantStream);
      },
    );
  }

  @override
  Future<List<ChatUser>> getUsers({required int retry, int? limit}) async {
    try {
      final userCollection = _usersCollectionRef().toQuery(limit: limit);
      final userSnapshot = await userCollection.get();
      return _getUsersFromSnapshot(userSnapshot);
    } catch (_) {
      if (retry == 0) rethrow;
      return getUsers(limit: limit, retry: --retry);
    }
  }

  @override
  Future<ChatRoomMetadata?> getChatRoomMetadata({
    required int retry,
    required String chatId,
    required String userId,
  }) async {
    try {
      final chatRoomResult =
          await ChatViewFireStoreCollections.chatCollection().doc(chatId).get();

      final chatRoom = chatRoomResult.data();

      if (chatRoom == null) return null;

      final results = await _getChatRoomParticipantsWithDetails(
        chatId: chatId,
        userId: userId,
      );
      final resultsLength = results.length;

      ChatUser? currentUser;
      final otherUsers = <ChatUser>[];

      for (var i = 0; i < resultsLength; i++) {
        final user = results[i].chatUser;
        if (user == null) continue;
        if (user.id == userId) {
          currentUser = user;
        } else {
          otherUsers.add(user);
        }
      }

      if (currentUser == null || otherUsers.isEmpty) return null;

      return ChatRoomMetadata(
        chatRoomType: chatRoom.chatRoomType,
        groupName: chatRoom.groupName,
        groupPhotoUrl: chatRoom.groupPhotoUrl,
        currentUser: currentUser,
        otherUsers: otherUsers,
      );
    } catch (_) {
      if (retry == 0) rethrow;
      return getChatRoomMetadata(
        retry: --retry,
        chatId: chatId,
        userId: userId,
      );
    }
  }

  @override
  Stream<List<ChatUser>> getUsersStream({int? limit}) {
    return _usersCollectionRef()
        .toQuery(limit: limit)
        .snapshots()
        .map(_getUsersFromSnapshot);
  }

  List<ChatUser> _getUsersFromSnapshot(
    QuerySnapshot<ChatUser?> result,
  ) {
    final docs = result.docs;
    final docsLength = docs.length;
    return <ChatUser>[
      for (var i = 0; i < docsLength; i++)
        if (docs[i].data() case final chatUser?) chatUser,
    ];
  }

  @override
  Stream<ChatUser?> getUserStreamById(String userId) {
    return _usersCollectionRef()
        .doc(userId)
        .snapshots()
        .distinct((previous, next) => previous.data() == next.data())
        .map((chatUserDoc) => chatUserDoc.data());
  }

  @override
  Future<void> updateChatRoomUserMetadata({
    required int retry,
    required String chatId,
    required String userId,
    TypeWriterStatus? typingStatus,
    MembershipStatus? membershipStatus,
    PinStatus? pinStatus,
    MuteStatus? muteStatus,
    Map<String, dynamic>? chatRoomUserData,
    ValueGetter<ChatRoomParticipant>? ifDataNotFound,
  }) async {
    try {
      final data = chatRoomUserData ??
          <String, dynamic>{
            if (typingStatus case final status?) _typingStatus: status.name,
            if (membershipStatus case final status?) ...{
              _membershipStatus: status.name,
              _membershipStatusTimestamp: FieldValue.serverTimestamp(),
            },
            if (pinStatus case final status?) ...{
              _pinStatus: status.name,
              _pinStatusTimestamp:
                  pinStatus.isPinned ? FieldValue.serverTimestamp() : null,
            },
            if (muteStatus case final status?) _muteStatus: status.name,
          };

      if (data.isEmpty) return;

      await ChatViewFireStoreCollections.chatParticipantsCollection(
        _chatRoomCollectionPath(chatId),
      ).doc(userId).update(data);
    } on FirebaseException catch (exception) {
      switch (FirestoreExceptionTypeExtension.fromCode(exception.code)) {
        case FirestoreExceptionType.notFound when ifDataNotFound != null:
          return _createChatRoomUserMetadata(
            // No need to pass a negative retry value since
            // an internal retry mechanism is already implemented.
            retry: retry,
            chatId: chatId,
            userId: userId,
            participant: ifDataNotFound(),
          );
        case FirestoreExceptionType.notFound ||
              FirestoreExceptionType.permissionDenied ||
              FirestoreExceptionType.unknown:
          if (retry == 0) rethrow;
          return updateChatRoomUserMetadata(
            retry: --retry,
            userId: userId,
            chatId: chatId,
            typingStatus: typingStatus,
            membershipStatus: membershipStatus,
            chatRoomUserData: chatRoomUserData,
            ifDataNotFound: ifDataNotFound,
          );
      }
    }
  }

  Future<void> _createChatRoomUserMetadata({
    required int retry,
    required String chatId,
    required String userId,
    required ChatRoomParticipant participant,
  }) async {
    try {
      await ChatViewFireStoreCollections.chatParticipantsCollection(
        _chatRoomCollectionPath(chatId),
      ).doc(userId).set(participant);
    } catch (_) {
      if (retry == 0) rethrow;
      return _createChatRoomUserMetadata(
        retry: --retry,
        chatId: chatId,
        userId: userId,
        participant: participant,
      );
    }
  }

  @override
  Future<bool> updateUserActiveStatus({
    required int retry,
    required String userId,
    required UserActiveStatus userStatus,
  }) async {
    try {
      await ChatViewFireStoreCollections.userChatCollection()
          .doc(userId)
          .update(UserMetadata(userActiveStatus: userStatus).toJson());
      return true;
    } on FirebaseException catch (exception) {
      switch (FirestoreExceptionTypeExtension.fromCode(exception.code)) {
        case FirestoreExceptionType.notFound:
          return _setUserActiveStatus(
            // No need to pass a negative retry value since
            // an internal retry mechanism is already implemented.
            retry: retry,
            id: userId,
            status: userStatus,
          );
        case FirestoreExceptionType.permissionDenied ||
              FirestoreExceptionType.unknown:
          if (retry == 0) return false;
          return updateUserActiveStatus(
            retry: --retry,
            userId: userId,
            userStatus: userStatus,
          );
      }
    }
  }

  Future<bool> _setUserActiveStatus({
    required int retry,
    String? id,
    UserActiveStatus status = UserActiveStatus.offline,
  }) async {
    try {
      await ChatViewFireStoreCollections.userChatCollection()
          .doc(id)
          .set(UserMetadata(userActiveStatus: status));
      return true;
    } on FirebaseException catch (_) {
      if (retry == 0) return false;
      return _setUserActiveStatus(
        retry: --retry,
        id: id,
        status: status,
      );
    }
  }

  @override
  Stream<Map<String, ChatRoomParticipant>> getChatRoomUsersMetadataStream({
    required String chatId,
    required String userId,
    required bool observeUserInfoChanges,
    int? limit,
  }) {
    final userCollection =
        ChatViewFireStoreCollections.chatParticipantsCollection(
      _chatRoomCollectionPath(chatId),
    ).toQuery(limit: limit);

    return userCollection.snapshots().switchMap(
      (userSnapshot) {
        final docs = userSnapshot.docs;
        final docsLength = docs.length;
        final users = <String, ChatRoomParticipant>{};
        for (var i = 0; i < docsLength; i++) {
          final chatRoomUser = docs[i].data();
          if (chatRoomUser == null) continue;
          final chatUserId = chatRoomUser.userId;
          if (chatUserId == userId) continue;
          users[chatUserId] = chatRoomUser;
        }
        if (!observeUserInfoChanges) return Stream.value(users);

        final newUsers = users.values.toList();
        final usersLength = newUsers.length;
        final chatRoomParticipantWithInfo = <Stream<ChatRoomParticipant>>[
          for (var i = 0; i < usersLength; i++)
            if (newUsers[i] case final chatRoomUser)
              _getUserInfoWithStatusStream(chatRoomUser.userId).map(
                (userResult) {
                  final user = chatRoomUser.copyWith(
                    chatUser: userResult.user,
                    userActiveStatus: userResult.userActiveStatus,
                  );
                  users[chatRoomUser.userId] = user;
                  return user;
                },
              ),
        ];

        return Rx.combineLatest(chatRoomParticipantWithInfo, (_) => users);
      },
    );
  }

  Future<List<ChatRoomParticipant>> _getChatRoomParticipantsWithDetails({
    required String chatId,
    required String userId,
    bool includeCurrentUser = true,
  }) async {
    final collectionPath = _chatRoomCollectionPath(chatId);

    final currentChatID =
        collectionPath.chatId ?? ChatViewConnectConstants.emptyString;

    if (currentChatID.isEmpty) {
      throw Exception('Chat ID not found from path: $collectionPath');
    }

    final userCollectionSnapshot =
        await ChatViewFireStoreCollections.chatParticipantsCollection(
      collectionPath,
    ).get();

    final docs = userCollectionSnapshot.docs;
    if (docs.isEmpty) {
      throw Exception('No users found in chat ID: $currentChatID');
    }

    final docsLength = docs.length;
    final chatRoomParticipants = <String, ChatRoomParticipant>{};
    final chatRoomUsersInfoFutures = <Future<void>>[];

    for (var i = 0; i < docsLength; i++) {
      final doc = docs[i];
      final chatUserId = doc.id;
      if (!includeCurrentUser && chatUserId == userId) {
        continue;
      }
      final chatRoomUser = doc.data();
      if (chatRoomUser == null) continue;
      chatRoomParticipants[chatUserId] = chatRoomUser;
      chatRoomUsersInfoFutures.add(
        _usersCollectionRef().doc(chatUserId).get().then(
          (chatUserDoc) {
            final userData = chatUserDoc.data() ??
                ChatUser(id: chatUserId, name: 'Unknown User');
            final chatRoomUser = chatRoomParticipants[chatUserId];
            if (chatRoomUser != null) {
              chatRoomParticipants[chatUserId] =
                  chatRoomUser.copyWith(chatUser: userData);
            }
          },
        ),
      );
    }

    await Future.wait(chatRoomUsersInfoFutures);
    return chatRoomParticipants.values.toList();
  }

  @override
  Stream<List<ChatRoom>> getChatsStream({
    required String userId,
    required ChatSortBy sortBy,
    required bool includeEmptyChats,
    required bool includeUnreadMessagesCount,
    int? limit,
  }) {
    final chatRoomCollection =
        ChatViewFireStoreCollections.userConversationsCollection(
      userId: userId,
    );

    return chatRoomCollection.snapshots().switchMap(
      (userChatsSnapshot) {
        final docs = userChatsSnapshot.docs;
        if (docs.isEmpty) return Stream.value([]);
        return _getChatsWithLastMessageStream(
          limit: limit,
          userId: userId,
          sortBy: sortBy,
          userChatsSnapshot: docs,
          chatRoomId: (snapshot) => snapshot.id,
        ).switchMap(
          (chatLastMessages) => chatLastMessages.isEmpty
              ? Stream.value([])
              : CombineLatestStream(
                  _getChatsStream(
                    userId: userId,
                    chatLastMessages: chatLastMessages,
                    includeEmptyChats: includeEmptyChats,
                    includeUnreadMessagesCount: includeUnreadMessagesCount,
                  ),
                  (chats) => chats.toNonEmpty,
                ),
        );
      },
    );
  }

  List<Stream<ChatRoom>> _getChatsStream({
    required String userId,
    required bool includeEmptyChats,
    required bool includeUnreadMessagesCount,
    required Map<String, Message?> chatLastMessages,
  }) {
    final chatIds = chatLastMessages.keys.toList();
    final chatIdsLength = chatIds.length;
    return [
      for (var i = 0; i < chatIdsLength; i++)
        if (chatIds[i] case final chatId)
          _retrieveChatRoomWithParticipants(
            userId: userId,
            chatId: chatId,
            lastMessage: chatLastMessages[chatId],
            includeEmptyChats: includeEmptyChats,
            includeUnreadMessagesCount: includeUnreadMessagesCount,
          ),
    ];
  }

  Stream<Map<String, Message?>> _getChatsWithLastMessageStream<T>({
    required String userId,
    required ChatSortBy sortBy,
    required List<T> userChatsSnapshot,
    required ChatRoomIdCallback<T> chatRoomId,
    WhereCallback<T>? shouldSkipSnapshot,
    int? limit,
  }) {
    var chats = <String, Message?>{};
    final messageStreams = <Stream<Message?>>[];
    final length = userChatsSnapshot.length;

    for (var i = 0; i < length; i++) {
      final snapshot = userChatsSnapshot[i];
      final chatId = chatRoomId(snapshot);

      if (shouldSkipSnapshot?.call(snapshot) ?? false) continue;

      messageStreams.add(
        _getLastMessageStream(chatRoomId: chatId, userId: userId).map(
          (message) => chats[chatId] = message,
        ),
      );
    }

    return CombineLatestStream(
      messageStreams,
      (_) {
        if (sortBy.isNewestFirst) {
          chats = Map.fromEntries(
            chats.entries.toList()
              ..sort((e1, e2) => e2.value.compareUpdateAt(e1.value)),
          );
        }
        if (limit != null) {
          chats = Map.fromEntries(chats.entries.take(limit));
        }
        return chats;
      },
    );
  }

  @override
  Stream<ChatRoom> chatRoomChangesStream({
    required String userId,
    required bool includeEmptyChats,
    required bool includeUnreadMessagesCount,
    required ValueSetter<String>? onRemovedChat,
    int? limit,
  }) {
    final chatRoomCollection =
        ChatViewFireStoreCollections.userConversationsCollection(
      userId: userId,
    );

    return chatRoomCollection
        .snapshots()
        .where((snapshot) => snapshot.docChanges.isNotEmpty)
        .switchMap(
      (userChatsSnapshot) {
        final docs = userChatsSnapshot.docChanges;
        final docsLength = docs.length;

        final streams = <Stream<ChatRoom>>[];

        for (var i = 0; i < docsLength; i++) {
          final snapshot = docs[i];
          final chatId = snapshot.doc.id;
          if (snapshot.type == DocumentChangeType.removed) {
            onRemovedChat?.call(chatId);
            continue;
          }

          streams.add(
            _getLastMessageStream(chatRoomId: chatId, userId: userId).switchMap(
              (message) => _retrieveChatRoomWithParticipants(
                userId: userId,
                chatId: chatId,
                lastMessage: message,
                includeEmptyChats: includeEmptyChats,
                includeUnreadMessagesCount: includeUnreadMessagesCount,
              ),
            ),
          );
        }

        return Rx.merge(streams);
      },
    );
  }

  Stream<ChatRoom> _retrieveChatRoomWithParticipants({
    required String userId,
    required String chatId,
    required Message? lastMessage,
    required bool includeEmptyChats,
    required bool includeUnreadMessagesCount,
  }) {
    return _chatRoomStream(userId: userId, chatRoomId: chatId)
        .distinct((previous, next) => previous == next)
        .where(
          (chatRoom) {
            final isInvalidChatRoom = chatRoom == null ||
                (!includeEmptyChats &&
                    chatRoom.chatRoomType.isOneToOne &&
                    chatRoom.lastMessage == null);
            return !isInvalidChatRoom;
          },
        )
        .cast<ChatRoom>()
        .switchMap(
          (chatRoom) {
            return getChatRoomParticipantsStream(
              userId: userId,
              chatId: chatRoom.chatId,
              includeCurrentUser: true,
              listenChangesForCurrentUser: true,
            ).switchMap(
              (participants) => _getChatRoomFromParticipantsStream(
                userId: userId,
                participants: participants,
                chatRoom: chatRoom.copyWith(
                  lastMessage: lastMessage,
                ),
                fetchUnreadMessageCount: includeUnreadMessagesCount,
              ),
            );
          },
        );
  }

  Stream<ChatRoom?> _chatRoomStream({
    required String chatRoomId,
    required String userId,
    bool fetchLastMessage = false,
  }) {
    return ChatViewFireStoreCollections.chatCollection()
        .doc(chatRoomId)
        .snapshots()
        .distinct((previous, next) => previous == next)
        .switchMap(
      (snapshot) {
        final chatRoom = snapshot.data();
        return fetchLastMessage
            ? _getLastMessageStream(chatRoomId: chatRoomId, userId: userId).map(
                (message) => chatRoom?.copyWith(lastMessage: message),
              )
            : Stream.value(chatRoom);
      },
    );
  }

  Stream<Message?> _getLastMessageStream({
    required String chatRoomId,
    required String userId,
  }) {
    final updateAtMessageCollection =
        _messageCollectionRef(chatRoomId).toMessageQuery(
      sortBy: MessageSortBy.updateAt,
      sortOrder: MessageSortOrder.desc,
      limit: 1,
    );

    return updateAtMessageCollection
        .snapshots()
        .distinct(
          (prev, next) =>
              prev.docs.firstOrNull?.data() == next.docs.firstOrNull?.data(),
        )
        .switchMap(
      (snapshot) {
        final message = snapshot.docs.firstOrNull?.data();
        if (message == null) return Stream.value(null);
        final reactedByUserId = message.update?[_reaction]?.toString() ??
            ChatViewConnectConstants.emptyString;
        final showReactionMessage =
            message.sentBy == userId || reactedByUserId == userId;
        return showReactionMessage
            ? Stream.value(message)
            : _messageCollectionRef(chatRoomId)
                .toMessageQuery(
                  sortBy: MessageSortBy.createAt,
                  sortOrder: MessageSortOrder.desc,
                  limit: 1,
                )
                .snapshots()
                .map((snapshot) => snapshot.docs.firstOrNull?.data());
      },
    );
  }

  Stream<ChatRoom> _getChatRoomFromParticipantsStream({
    required String userId,
    required ChatRoom chatRoom,
    required bool fetchUnreadMessageCount,
    required List<ChatRoomParticipant> participants,
  }) {
    ChatRoomParticipant? currentUser;
    final List<ChatRoomParticipant> otherUsers;
    final result = _getChatRoomParticipant(
      participants: participants,
      userId: userId,
    );
    currentUser = result.currentUser;
    otherUsers = result.otherUsers;

    final membershipTimestamp = currentUser?.membershipStatusTimestamp;

    final unreadMessagesCountStream = fetchUnreadMessageCount
        ? getUnreadMessagesCount(
            userId: userId,
            chatId: chatRoom.chatId,
            from: membershipTimestamp,
          )
        : Stream.value(0);

    final isMessageBeforeMembership =
        membershipTimestamp.isMessageBeforeMembership(
      chatRoom.lastMessage?.createdAt,
    );

    return unreadMessagesCountStream.map(
      (unreadMessagesCount) => chatRoom.copyWith(
        forceNullValue: true,
        pinnedAt: currentUser?.pinStatusTimestamp,
        muteStatus: currentUser?.muteStatus,
        pinStatus: currentUser?.pinStatus,
        users: otherUsers,
        chatId: chatRoom.chatId,
        groupName: chatRoom.groupName,
        chatRoomType: chatRoom.chatRoomType,
        groupPhotoUrl: chatRoom.groupPhotoUrl,
        chatRoomCreateBy: chatRoom.chatRoomCreateBy,
        unreadMessagesCount: unreadMessagesCount,
        lastMessage: isMessageBeforeMembership ? null : chatRoom.lastMessage,
      ),
    );
  }

  @override
  Future<String?> createOneToOneChat({
    required String userId,
    required String otherUserId,
    String? chatRoomId,
  }) async {
    final participants = <String, Role>{
      userId: Role.admin,
      otherUserId: Role.admin,
    };

    final participantsLength = participants.length;

    final ids = participants.keys.toList();

    final isUsersExistsUserInCollection = await Future.wait([
      for (var i = 0; i < participantsLength; i++) _doesUserExists(ids[i]),
    ]);

    final isAllUserExistsInUserCollection = isUsersExistsUserInCollection.fold(
      true,
      (value, isUserExist) => value && isUserExist,
    );

    if (!isAllUserExistsInUserCollection) {
      throw Exception('Some of User IDs($participants) not exists');
    }

    final chatId = await _doesChatExists(
      userId: userId,
      otherUserId: otherUserId,
    );

    if (chatId?.isNotEmpty ?? false) return chatId;

    final newChatId = await _createChatAndAddUsers(
          currentUserId: userId,
          participants: participants,
          membershipStatus: MembershipStatus.member,
          chatRoom: ChatRoom(
            chatId: chatRoomId ?? const Uuid().v8(),
            chatRoomType: ChatRoomType.oneToOne,
          ),
        ) ??
        ChatViewConnectConstants.emptyString;

    if (newChatId.isEmpty) return null;

    final isAllChatAddedInAllUsers = await _addUsersInChat(
      userIds: ids,
      chatId: newChatId,
      chatType: ChatRoomType.oneToOne,
    );

    if (!isAllChatAddedInAllUsers) {
      await deleteChat(chatId: newChatId, retry: 0);
      return null;
    }

    return newChatId;
  }

  @override
  Future<String?> createGroupChat({
    required String userId,
    required String groupName,
    required Map<String, Role> participants,
    String? groupProfilePic,
    String? chatRoomId,
  }) async {
    participants[userId] = Role.admin;
    final userIdsLength = participants.length;

    if (userIdsLength < 2) throw Exception("User IDs can't be empty!");

    final ids = participants.keys.toList();

    final isUsersExistsUserInCollection = await Future.wait([
      for (var i = 0; i < userIdsLength; i++) _doesUserExists(ids[i]),
    ]);

    final isAllUserExistsInUserCollection = isUsersExistsUserInCollection.fold(
      true,
      (value, isUserExist) => value && isUserExist,
    );

    if (!isAllUserExistsInUserCollection) {
      throw Exception('Some of User IDs($participants) not exists');
    }

    final chatId = await _createChatAndAddUsers(
          currentUserId: userId,
          participants: participants,
          membershipStatus: MembershipStatus.member,
          chatRoom: ChatRoom(
            chatId: chatRoomId ?? const Uuid().v8(),
            groupName: groupName,
            groupPhotoUrl: groupProfilePic,
            chatRoomCreateBy: userId,
            chatRoomType: ChatRoomType.group,
          ),
        ) ??
        ChatViewConnectConstants.emptyString;

    if (chatId.isEmpty) return null;

    final isAllChatAddedInAllUsers = await _addUsersInChat(
      userIds: ids,
      chatId: chatId,
      chatType: ChatRoomType.group,
    );

    if (!isAllChatAddedInAllUsers) {
      await deleteChat(chatId: chatId, retry: 0);
      return null;
    }

    return chatId;
  }

  @override
  Future<bool> updateGroupChat({
    required int retry,
    required String chatId,
    String? groupName,
    String? groupProfilePic,
  }) async {
    final data = <String, dynamic>{
      if (groupName?.isNotEmpty ?? false) _groupName: groupName,
      if (groupProfilePic != null) _groupPhotoUrl: groupProfilePic,
    };

    if (data.isEmpty) return true;

    // No need to pass a negative retry value since
    // an internal retry mechanism is already implemented.
    return _updateChatRoom(retry: retry, chatId: chatId, data: data);
  }

  Future<bool> _updateChatRoom({
    required int retry,
    required String chatId,
    required Map<String, dynamic> data,
  }) async {
    try {
      await ChatViewFireStoreCollections.chatCollection()
          .doc(chatId)
          .update(data);
      return true;
    } on FirebaseException catch (_) {
      if (retry == 0) return false;
      return _updateChatRoom(retry: --retry, chatId: chatId, data: data);
    }
  }

  /// To create one to one chat document at path of 'user_chats/[currentUserId]/chats/[chatId]' .
  Future<bool> _createChatInUserChats({
    required String chatId,
    required String currentUserId,
    required String? otherUserId,
  }) async {
    try {
      await ChatViewFireStoreCollections.userConversationsCollection(
        userId: currentUserId,
      ).doc(chatId).set(UserChatMetadata(userId: otherUserId));
      return true;
    } catch (_) {
      return false;
    }
  }

  Future<String?> _createChatAndAddUsers({
    required String currentUserId,
    required Map<String, Role> participants,
    required ChatRoom chatRoom,
    MembershipStatus? membershipStatus,
  }) async {
    final chatId = chatRoom.chatId;

    final isChatCreated = await _createChat(chatId: chatId, chatRoom: chatRoom);

    if (!isChatCreated) return null;

    final isCurrentUserAddedInChatRoom = await _addUserInChat(
      chatId: chatId,
      participant: ChatRoomParticipant(
        chatUser: null,
        userId: currentUserId,
        role: Role.admin,
        membershipStatusTimestamp: null,
        membershipStatus: membershipStatus,
        pinStatusTimestamp: null,
      ),
    );

    if (isCurrentUserAddedInChatRoom) {
      participants.remove(currentUserId);
    } else {
      await deleteChat(chatId: chatId, retry: 0);
      return null;
    }

    final participantsLength = participants.length;
    final ids = participants.keys.toList();

    final isUsersAddedInChatRoom = await Future.wait(
      [
        for (var i = 0; i < participantsLength; i++)
          if (ids[i] case final userId)
            _addUserInChat(
              chatId: chatId,
              participant: ChatRoomParticipant(
                chatUser: null,
                userId: userId,
                membershipStatusTimestamp: null,
                membershipStatus: membershipStatus,
                role: participants[userId] ?? Role.admin,
                pinStatusTimestamp: null,
              ),
            ),
      ],
    );

    final isAllUsersAddedInChatRoom = isUsersAddedInChatRoom.fold(
      true,
      (value, isAdded) => value && isAdded,
    );

    if (!isAllUsersAddedInChatRoom) {
      await deleteChat(chatId: chatId, retry: 0);
      return null;
    }

    return chatId;
  }

  Future<bool> _addUsersInChat({
    required List<String> userIds,
    required String chatId,
    required ChatRoomType chatType,
  }) async {
    final userIdsLength = userIds.length;
    final isOneToOne = chatType.isOneToOne && userIdsLength == 2;
    final isChatAddedInAllUsers = await Future.wait([
      for (var i = 0; i < userIdsLength; i++)
        if (userIds[i] case final userId)
          _createChatInUserChats(
            chatId: chatId,
            currentUserId: userId,
            otherUserId: isOneToOne ? userIds[1 - i] : null,
          ),
    ]);
    final isAllChatAddedInAllUsers = isChatAddedInAllUsers.fold(
      true,
      (value, isAdded) => value && isAdded,
    );
    return isAllChatAddedInAllUsers;
  }

  Future<bool> _addUserInChat({
    required String chatId,
    required ChatRoomParticipant participant,
  }) async {
    try {
      await ChatViewFireStoreCollections.chatParticipantsCollection(
        _chatRoomCollectionPath(chatId),
      ).doc(participant.userId).set(participant);
      return true;
    } catch (_) {
      return false;
    }
  }

  Future<bool> _createChat({
    required String chatId,
    required ChatRoom chatRoom,
  }) async {
    try {
      await ChatViewFireStoreCollections.chatCollection()
          .doc(chatId)
          .set(chatRoom);
      return true;
    } catch (_) {
      return false;
    }
  }

  @override
  Future<String?> findOneToOneChatRoom({
    required int retry,
    required String userId,
    required String otherUserId,
  }) async {
    try {
      final isOtherUserExist = await _doesUserExists(otherUserId);
      if (!isOtherUserExist) {
        throw Exception('User ID($otherUserId) not exists');
      }
      final chatId = await _doesChatExists(
        otherUserId: otherUserId,
        userId: userId,
      );
      return chatId;
    } catch (_) {
      if (retry == 0) return null;
      return findOneToOneChatRoom(
        retry: --retry,
        userId: userId,
        otherUserId: otherUserId,
      );
    }
  }

  Future<String?> _doesChatExists({
    required String userId,
    required String otherUserId,
  }) async {
    try {
      final chatsSnapshot =
          await ChatViewFireStoreCollections.userConversationsCollection(
        userId: userId,
      ).get();

      final docs = chatsSnapshot.docs;
      final docsLength = docs.length;
      for (var i = 0; i < docsLength; i++) {
        final doc = docs[i];
        final chatUserId = doc.data()?.userId;
        if (chatUserId == otherUserId) return doc.id;
      }
      return null;
    } on FirebaseException catch (e) {
      final code = FirestoreExceptionTypeExtension.fromCode(e.code);
      switch (code) {
        case FirestoreExceptionType.notFound ||
              FirestoreExceptionType.permissionDenied:
          return null;
        case FirestoreExceptionType.unknown:
          rethrow;
      }
    }
  }

  Future<bool> _doesUserExists(String userId) async {
    final result = await _usersCollectionRef().doc(userId).get();
    return result.exists;
  }

  @override
  Future<bool> deleteChat({
    required int retry,
    required String chatId,
    DeleteChatMediaCallback? deleteMedia,
  }) async {
    try {
      final chatRoomCollectionPath = _chatRoomCollectionPath(chatId);

      final userCollection =
          ChatViewFireStoreCollections.chatParticipantsCollection(
        chatRoomCollectionPath,
      );

      final usersSnapshot = await userCollection.get();
      final usersSnapshotDocs = usersSnapshot.docs;
      final usersSnapshotDocsLength = usersSnapshotDocs.length;

      await Future.wait([
        for (var i = 0; i < usersSnapshotDocsLength; i++)
          if (usersSnapshotDocs[i].id case final userId)
            ChatViewFireStoreCollections.userConversationsCollection(
              userId: userId,
            ).doc(chatId).delete(),
      ]);

      /// for deleting chat medias
      await deleteMedia?.call(chatId);

      await _deleteNestedChatCollections(chatId);

      await Future.wait([
        for (var i = 0; i < usersSnapshotDocsLength; i++)
          if (usersSnapshotDocs[i].id case final userId)
            ChatViewFireStoreCollections.chatParticipantsCollection(
              chatRoomCollectionPath,
            ).doc(userId).delete(),
      ]);

      await ChatViewFireStoreCollections.chatCollection().doc(chatId).delete();

      return true;
    } catch (_) {
      if (retry == 0) return false;
      return deleteChat(
        retry: --retry,
        chatId: chatId,
        deleteMedia: deleteMedia,
      );
    }
  }

  Future<bool> _deleteNestedChatCollections(String chatId) async {
    final chatRoomCollection = _messageCollectionRef(chatId);

    final messagesSnapshot = await chatRoomCollection.get();

    final messagesSnapshotDocs = messagesSnapshot.docs;
    final messagesSnapshotDocsLength = messagesSnapshotDocs.length;

    await Future.wait([
      for (var i = 0; i < messagesSnapshotDocsLength; i++)
        chatRoomCollection.doc(messagesSnapshotDocs[i].id).delete(),
    ]);

    return true;
  }

  @override
  Future<bool> addUserInGroup({
    required int retry,
    required String chatId,
    required String userId,
    required Role role,
    required bool includeAllChatHistory,
    DateTime? startDate,
  }) async {
    final isUserExist = await _doesUserExists(userId);
    if (!isUserExist) throw Exception('User ID ($userId) not exists');

    final chatRoom = await _doesChatRoomExists(chatId);
    if (chatRoom == null) {
      throw Exception('Chat Room ($chatId) not exists');
    } else if (chatRoom.chatRoomType.isOneToOne) {
      throw Exception("User can't be added in one to one chat");
    }

    try {
      final userChatRoomCollection =
          ChatViewFireStoreCollections.chatParticipantsCollection(
        _chatRoomCollectionPath(chatId),
      );

      final userChatRoomData = await userChatRoomCollection.doc(userId).get();

      final userChatRoom = userChatRoomData.data();

      final memberStatus = userChatRoom?.membershipStatus;

      if (memberStatus == MembershipStatus.member) return true;

      var membershipStatusTime = includeAllChatHistory ? null : DateTime.now();

      if (startDate?.isNow ?? false) {
        membershipStatusTime = DateTime.now();
      }

      await updateChatRoomUserMetadata(
        retry: 0,
        userId: userId,
        chatId: chatId,
        chatRoomUserData: {
          _membershipStatus: MembershipStatus.member.name,
          _membershipStatusTimestamp: membershipStatusTime == null
              ? null
              : membershipStatusTime.isNow
                  ? FieldValue.serverTimestamp()
                  : Timestamp.fromDate(membershipStatusTime),
        },
        ifDataNotFound: () => ChatRoomParticipant(
          role: role,
          chatUser: null,
          userId: userId,
          membershipStatus: MembershipStatus.member,
          membershipStatusTimestamp: membershipStatusTime,
          pinStatusTimestamp: null,
        ),
      );

      await ChatViewFireStoreCollections.userConversationsCollection(
        userId: userId,
      ).doc(chatId).set(const UserChatMetadata());

      return true;
    } catch (_) {
      if (retry == 0) return false;
      return addUserInGroup(
        retry: --retry,
        chatId: chatId,
        userId: userId,
        role: role,
        startDate: startDate,
        includeAllChatHistory: includeAllChatHistory,
      );
    }
  }

  @override
  Future<bool> removeUserFromGroup({
    required int retry,
    required String chatId,
    required String userId,
    required String removeUserId,
    required bool deleteGroupIfSingleUser,
    required DeleteChatMediaCallback deleteChatMedia,
  }) async {
    final membershipStatus = userId == removeUserId
        ? MembershipStatus.left
        : MembershipStatus.removed;

    if (membershipStatus.isMember) throw Exception('In appropriate operation');

    final isUserExist = await _doesUserExists(removeUserId);
    if (!isUserExist) throw Exception('User ID ($removeUserId) not exists');

    final chatRoom = await _doesChatRoomExists(chatId);
    if (chatRoom == null) throw Exception('Chat Room ($chatId) not exists');

    if (chatRoom.chatRoomType.isOneToOne) {
      throw Exception("User can't be removed from the one to one chat");
    }

    try {
      final userChatRoomCollection =
          ChatViewFireStoreCollections.chatParticipantsCollection(
        _chatRoomCollectionPath(chatId),
      );

      ChatRoomParticipant? currentParticipant;

      if (deleteGroupIfSingleUser) {
        final userChatRoomCollectionData = await userChatRoomCollection.get();

        final docs = userChatRoomCollectionData.docs;
        final docsLength = docs.length;

        var activeMembers = 0;

        for (var i = 0; i < docsLength; i++) {
          final chatRoomUser = docs[i].data();
          if (chatRoomUser == null) continue;
          if (chatRoomUser.userId == removeUserId) {
            currentParticipant = chatRoomUser;
          }
          if (chatRoomUser.membershipStatus?.isMember ?? false) activeMembers++;
        }

        if (activeMembers == 1) {
          final result = await deleteChat(
            retry: 0,
            chatId: chatId,
            deleteMedia: deleteChatMedia,
          );
          return result;
        }
      } else {
        final userChatRoomData =
            await userChatRoomCollection.doc(removeUserId).get();
        currentParticipant = userChatRoomData.data();
      }

      await ChatViewFireStoreCollections.userConversationsCollection(
        userId: removeUserId,
      ).doc(chatId).delete();

      if (currentParticipant != null &&
          currentParticipant.membershipStatus != membershipStatus) {
        await updateChatRoomUserMetadata(
          retry: 0,
          userId: removeUserId,
          chatId: chatId,
          membershipStatus: membershipStatus,
        );
      }

      return true;
    } catch (_) {
      if (retry == 0) return false;
      return removeUserFromGroup(
        retry: --retry,
        chatId: chatId,
        userId: userId,
        removeUserId: removeUserId,
        deleteChatMedia: deleteChatMedia,
        deleteGroupIfSingleUser: deleteGroupIfSingleUser,
      );
    }
  }

  Future<ChatRoom?> _doesChatRoomExists(String chatRoomId) async {
    final result = await ChatViewFireStoreCollections.chatCollection()
        .doc(chatRoomId)
        .get();
    return result.data();
  }

  @override
  Stream<ChatRoomDisplayMetadata> getGroupChatDisplayMetadataStream(
    String chatId,
  ) {
    return ChatViewFireStoreCollections.chatCollection()
        .doc(chatId)
        .snapshots()
        .distinct(
      (previous, next) {
        final previousData = previous.data();
        final nextData = next.data();
        return previousData?.groupName == nextData?.groupName &&
            previousData?.groupPhotoUrl == nextData?.groupPhotoUrl;
      },
    ).map(
      (chatRoomSnapshot) {
        final chatRoom = chatRoomSnapshot.data();
        if (chatRoom == null || !chatRoom.chatRoomType.isGroup) {
          throw Exception('No Group Chat Found');
        }
        return ChatRoomDisplayMetadata(
          chatName: chatRoom.groupName ?? 'Unknown Group',
          chatProfilePhoto: chatRoom.groupPhotoUrl,
        );
      },
    );
  }

  @override
  Future<DateTime?> getUserMembershipTimestamp({
    required int retry,
    required String chatId,
    required String userId,
  }) async {
    try {
      final chatRoomUserData =
          await ChatViewFireStoreCollections.chatParticipantsCollection(
        _chatRoomCollectionPath(chatId),
      ).doc(userId).get();

      final chatRoomUser = chatRoomUserData.data();

      return switch (chatRoomUser?.membershipStatus) {
        MembershipStatus.member => chatRoomUser?.membershipStatusTimestamp,
        null || MembershipStatus.removed || MembershipStatus.left => null,
      };
    } on FirebaseException catch (_) {
      if (retry == 0) return null;
      return getUserMembershipTimestamp(
        retry: --retry,
        chatId: chatId,
        userId: userId,
      );
    }
  }

  @override
  Stream<ChatRoomDisplayMetadata> getChatRoomDisplayMetadataStream({
    required ChatRoomType chatRoomType,
    required String chatId,
    String? userId,
  }) {
    assert(
      chatRoomType.isGroup || chatRoomType.isOneToOne && userId != null,
      "User Id can't be null",
    );
    return switch (chatRoomType) {
      ChatRoomType.oneToOne when userId != null =>
        getUserStreamById(userId).map(
          (user) => ChatRoomDisplayMetadata(
            chatName: user?.name ?? 'Unknown User',
            chatProfilePhoto: user?.profilePhoto,
          ),
        ),
      ChatRoomType.group => getGroupChatDisplayMetadataStream(chatId),
      _ => Stream.value(
          const ChatRoomDisplayMetadata(chatName: 'Unknown User'),
        ),
    };
  }

  ChatRoomParticipantsRecord _getChatRoomParticipant({
    required String userId,
    required List<ChatRoomParticipant> participants,
  }) {
    final usersLength = participants.length;

    ChatRoomParticipant? currentUser;
    final otherUsers = <ChatRoomParticipant>[];

    for (var i = 0; i < usersLength; i++) {
      final user = participants[i];
      if (user.userId == userId) {
        currentUser = user;
      } else {
        otherUsers.add(user);
      }
    }

    return (currentUser: currentUser, otherUsers: otherUsers);
  }

  Stream<UserInfoWithStatusRecord> _getUserInfoWithStatusStream(String userId) {
    return Rx.combineLatest2(
      getUserStreamById(userId),
      ChatViewFireStoreCollections.userChatCollection()
          .doc(userId)
          .snapshots()
          .distinct((previous, next) => previous.data() == next.data()),
      (userInfo, userStatusSnapshot) => (
        user: userInfo,
        userActiveStatus: userStatusSnapshot.data()?.userActiveStatus,
      ),
    );
  }

  @override
  Future<List<Message>> getSurroundingMessages({
    required String chatId,
    required int retry,
    required String messageId,
    required int batchSize,
    required MessageSortBy sortBy,
    required MessageSortOrder sortOrder,
  }) async {
    // -1 to exclude the current message
    final surroundingMessagesCount = batchSize - 1;
    final firstSideMessageCount = surroundingMessagesCount ~/ 2;
    final secondSideMessageCount =
        surroundingMessagesCount - firstSideMessageCount;

    try {
      final messageCollectionRef = _messageCollectionRef(chatId).toMessageQuery(
        sortBy: sortBy,
        sortOrder: sortOrder,
      );

      final currentMessageResult =
          await _messageCollectionRef(chatId).doc(messageId).get();

      final currentMessage = currentMessageResult.data();
      if (currentMessage == null) return List<Message>.empty();

      final previousMessagesSnapshot = await messageCollectionRef
          .endBeforeDocument(currentMessageResult)
          .limitToLast(firstSideMessageCount)
          .get();

      final fetchedPreviousCount = previousMessagesSnapshot.docs.length;

      final remainingNextCount = fetchedPreviousCount != firstSideMessageCount
          ? surroundingMessagesCount - fetchedPreviousCount
          : secondSideMessageCount;

      final nextMessagesSnapshot = await messageCollectionRef
          .startAfterDocument(currentMessageResult)
          .limit(remainingNextCount)
          .get();

      final fetchedNextCount = nextMessagesSnapshot.docs.length;

      List<QueryDocumentSnapshot<Message?>>? additionalPreviousMessagesDocs;

      final firstPreviousDoc = previousMessagesSnapshot.docs.firstOrNull;

      // If next messages are fewer than expected and we still have earlier messages available
      if (fetchedNextCount != remainingNextCount && firstPreviousDoc != null) {
        // +1 to account for the current message
        final totalFetchedCount = fetchedPreviousCount + fetchedNextCount + 1;
        final remainingMessagesToFetch = batchSize - totalFetchedCount;

        final additionalPreviousSnapshot = await messageCollectionRef
            .endBeforeDocument(firstPreviousDoc)
            .limitToLast(remainingMessagesToFetch)
            .get();

        additionalPreviousMessagesDocs = additionalPreviousSnapshot.docs;
      }

      final allMessageDocs = [
        ...?additionalPreviousMessagesDocs,
        ...previousMessagesSnapshot.docs,
        currentMessageResult,
        ...nextMessagesSnapshot.docs,
      ];

      final allMessagesLength = allMessageDocs.length;

      return [
        for (var i = 0; i < allMessagesLength; i++)
          if (allMessageDocs[i].data() case final message?) message,
      ];
    } on FirebaseException catch (_) {
      if (retry == 0) return List<Message>.empty();
      return getSurroundingMessages(
        retry: --retry,
        chatId: chatId,
        sortBy: sortBy,
        messageId: messageId,
        sortOrder: sortOrder,
        batchSize: batchSize,
      );
    }
  }

  @override
  Future<List<Message>> getPreviousMessages({
    required String chatId,
    required int retry,
    required String messageId,
    required int batchSize,
  }) async {
    try {
      final messageCollectionRef = _messageCollectionRef(chatId).toMessageQuery(
        sortBy: MessageSortBy.createAt,
        sortOrder: MessageSortOrder.asc,
      );

      final currentMessageResult =
          await _messageCollectionRef(chatId).doc(messageId).get();

      final currentMessage = currentMessageResult.data();
      if (currentMessage == null) List<Message>.empty();

      final previousMessagesSnapshot = await messageCollectionRef
          .endBeforeDocument(currentMessageResult)
          .limitToLast(batchSize)
          .get();

      final docs = previousMessagesSnapshot.docs;
      final docsLength = docs.length;

      return [
        for (var i = 0; i < docsLength; i++)
          if (docs[i].data() case final message?) message,
      ];
    } on FirebaseException catch (_) {
      if (retry == 0) return List<Message>.empty();
      return getPreviousMessages(
        retry: --retry,
        chatId: chatId,
        messageId: messageId,
        batchSize: batchSize,
      );
    }
  }

  @override
  Future<List<Message>> getNextMessages({
    required String chatId,
    required int retry,
    required String messageId,
    required int batchSize,
  }) async {
    try {
      final messageCollectionRef = _messageCollectionRef(chatId).toMessageQuery(
        sortBy: MessageSortBy.createAt,
        sortOrder: MessageSortOrder.asc,
      );

      final currentMessageResult =
          await _messageCollectionRef(chatId).doc(messageId).get();

      final currentMessage = currentMessageResult.data();
      if (currentMessage == null) List<Message>.empty();

      final nextMessagesSnapshot = await messageCollectionRef
          .startAfterDocument(currentMessageResult)
          .limit(batchSize)
          .get();

      final docs = nextMessagesSnapshot.docs;
      final docsLength = docs.length;

      return [
        for (var i = 0; i < docsLength; i++)
          if (docs[i].data() case final message?) message,
      ];
    } on FirebaseException catch (_) {
      if (retry == 0) return List<Message>.empty();
      return getNextMessages(
        retry: --retry,
        chatId: chatId,
        messageId: messageId,
        batchSize: batchSize,
      );
    }
  }
}
